<!DOCTYPE html>
<html>
<head>
    <title>WebSocket Chat</title>
</head>
<body>
    <h2>WebSocket Chat</h2>
    <p>æ­¡è¿ä¾†åˆ°èŠå¤©å®¤ï¼Œ{{ username }}ï¼</p>
    <p><a href="{% url 'logout' %}">ç™»å‡º</a></p>

    <input type="text" id="messageInput" placeholder="è¼¸å…¥è¨Šæ¯">
    <button onclick="sendMessage()">é€å‡º</button>
    <ul id="messages"></ul>

    <script>
        const username = "{{ username }}";  // å¾ Django å‚³å…¥ç›®å‰ç™»å…¥ä½¿ç”¨è€…
        const roomName = "testroom";        // å¯æ›¿æ›æˆå‹•æ…‹èŠå¤©å®¤
        const messagesUl = document.getElementById("messages");

        let socket;
        let messageIds = [];
        let windowIsFocused = true;

        // ========================
        // ç•¶å‰è¦–çª—ç„¦é»ç›£æ§
        // ========================
        window.onfocus = () => {
            windowIsFocused = true;
            sendReadMessages(messageIds);
        };
        window.onblur = () => {
            windowIsFocused = false;
        };

        // ========================
        // ç™¼é€å·²è®€è¨Šæ¯
        // ========================
        function sendReadMessages(ids) {
            if (socket && socket.readyState === WebSocket.OPEN && ids.length > 0) {
                socket.send(JSON.stringify({
                    type: "read_messages",
                    message_ids: ids
                }));
            }
        }

        // ========================
        // æ¸²æŸ“(é¡¯ç¤º)ä¸€å‰‡è¨Šæ¯
        // ========================
        function renderMessage({ id, sender, message, read_count, unread_count }) {
            const li = document.createElement("li"); // å»ºç«‹æ–°çš„åˆ—è¡¨é …ç›®
            li.textContent = `${sender}: ${message} ï¼ˆå·²è®€ ${read_count} äºº, æœªè®€ ${unread_count} äººï¼‰`; // è¨­å®šå…§å®¹
            li.dataset.id = id; // å„²å­˜è¨Šæ¯ ID ä»¥ä¾¿å¾ŒçºŒæ“ä½œ
            messagesUl.appendChild(li);  // å°‡æ–°é …ç›®åŠ å…¥messages åˆ—è¡¨
        }

        // ========================
        // æ›´æ–°å·²è®€ç‹€æ…‹
        // ========================
        function updateReadStatus(messageId, readCount, unreadCount) {
            const targetLi = [...messagesUl.children].find(li => li.dataset.id == messageId); // æ‰¾åˆ°å°æ‡‰çš„è¨Šæ¯é …ç›®
            if (targetLi) {
                const prefix = targetLi.textContent.split("ï¼ˆ")[0];
                targetLi.textContent = `${prefix}ï¼ˆå·²è®€ ${readCount} äºº, æœªè®€ ${unreadCount} äººï¼‰`;
            }
        }

        // ========================
        // è™•ç†æ­·å²è¨Šæ¯è¼‰å…¥
        // ========================
        async function loadHistory() {
            try {
                const response = await fetch(`/chat/messages/${roomName}/`);
                const data = await response.json();
                console.log("ğŸ“œ æ­·å²è¨Šæ¯ï¼š", data.messages);

                for (const msg of data.messages) {
                    if (msg.id == null) {
                        console.warn("âš ï¸ ç™¼ç¾æ²’æœ‰ ID çš„è¨Šæ¯", msg);
                        continue;
                    }
                    renderMessage(msg);
                    messageIds.push(msg.id);
                }
                console.log("âœ… æ­·å²è¨Šæ¯è¼‰å…¥å®Œæˆ", messageIds);
            } catch (err) {
                console.error("âŒ è¼‰å…¥æ­·å²è¨Šæ¯å¤±æ•—", err);
            }
        }

        // ========================
        // å»ºç«‹ WebSocket ä¸¦è™•ç†è¨Šæ¯
        // ========================
        function connectWebSocket() {
            socket = new WebSocket(`ws://localhost:5002/ws/chat/${roomName}/`);

            socket.onopen = () => {
                console.log("ğŸ”Œ WebSocket å·²é€£ç·š");
                if (windowIsFocused) {
                    sendReadMessages(messageIds);
                }
            };

            socket.onmessage = (event) => {
                const data = JSON.parse(event.data);
                // console.log("ğŸ’¬ æ”¶åˆ°è¨Šæ¯", data);

                if (data.type === "chat_message") { // è™•ç†èŠå¤©è¨Šæ¯
                    const { message_id, sender, message, read_count, unread_count } = data;
                    renderMessage({
                        id: message_id,
                        sender,
                        message,
                        read_count,
                        unread_count
                    });
                    // ç¢ºä¿è¨Šæ¯ ID å”¯ä¸€
                    if (!messageIds.includes(message_id)) {
                        messageIds.push(message_id);
                    }
                    // è¦–çª—èšç„¦æ™‚ï¼Œç«‹å³ç™¼é€å·²è®€è¨Šæ¯
                    if (windowIsFocused) {
                        sendReadMessages([message_id]);
                    }

                } else if (data.type === "read_update") { // è™•ç†å·²è®€æ›´æ–°
                    updateReadStatus(data.message_id, data.read_count, data.unread_count);
                }
            };

            socket.onerror = (e) => console.error("âŒ WebSocket éŒ¯èª¤", e);
            socket.onclose = () => console.warn("ğŸ”Œ WebSocket å·²é—œé–‰");
        }

        // ========================
        // ç™¼é€è¨Šæ¯
        // ========================
        function sendMessage() {
            const input = document.getElementById("messageInput");
            const text = input.value.trim();
            if (!text || !socket || socket.readyState !== WebSocket.OPEN) return;

            socket.send(JSON.stringify({
                type: "chat_message",
                message: text,
                sender: username
            }));
            input.value = "";
        }

        // ========================
        // åˆå§‹åŒ–èŠå¤©ç³»çµ±
        // ========================
        async function initChat() {
            await loadHistory();     // å…ˆè¼‰å…¥æ­·å²è¨Šæ¯
            connectWebSocket();      // å†å»ºç«‹ WebSocket
        }

        initChat(); // å•Ÿå‹•
    </script>
</body>
</html>
